{"./":{"url":"./","title":"首页","keywords":"","body":" 该书的原则： 只学习一遍，不再回头 坚持发散性思维，把各个技术都 扩展、深入 大神外链 魏双大神总结1 魏双大神总结2 TODO 求推荐好用的画图工具 未完成的文章，可以使用添加类似 xxxx 的语法去除链接 公共知识 ❌ xxx 性能优化 ❌ xxx JS ❌ xxx CSS ❌ xxx HTML ❌ xxx 技能指南 写作帮助 gitbook 的制作 阮一峰文章写作指南 模拟数据接口 接口地址使用：www.api.github.com get 请求 https://api.github.com/users/yeyuguo/repos 引用外部文件 || 执行 引用脚本文件或执行 渲染脚本 markdown 命令 ` Error: file not found: /Users/yeyuguo/Code/my-gitbook/xxx/xxxx.js ` By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:54:33 "},"common/":{"url":"common/","title":"公共知识","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:45:20 "},"common/DNS解析.html":{"url":"common/DNS解析.html","title":"DNS 解析 ","keywords":"","body":"学习掌握概览 等级 What Why How - [怎么做] 初级 基础概念 为什么需要它 基本使用 - [为什么] 中级 - 如果我不用它呢 有没有什么类似的工具或方式呢 - [做最好] 高级 - 有没有更好的实现方式呢？ 如果是自己来实现，你会如何做呢？ 参考文章 CND 缓存加速 What 1.它是什么，做什么的？ \bDNS 概念： 域名是服务器的名称 DNS 作用： 目的是让人容易记住服务器名称，服务器之间的通信都是通过IP地址交互的 -> 分为 client 和 Server 端 DNS 解析：DNS 转换成 IP 地址的过程，称为 DNS 解析 Why 1.为什么需要它？ 目的是为了转换 域名变成 IP 2.如果我不用它呢？ 不使用它，没办法和其他计算机交互 3.有没有什么类似的工具或方式呢？ DNS 本地 Server ：本地计算机的 DNS server DNS Server：公共的 DNS 服务 DNS \b转发器：负责转发一个 DNS 到目的 DNS 上 DNS 缓存器 阿里的缓存 223.5.5.5 223.6.6.6 谷歌的 8.8.8.8 8.8.4.4 号称最快最安全 1.1.1.1 How 1.我该如何使用它？ 转发（递归）：依次向上寻找 dns server 查找域名对应IP，查到返回给 本地 dns; 方式：加速 或 缓存 不转发 (迭代)：从 root DNS服务器 ( A - M )\b 依次查找，查到返回给 本地 dns; 传统的 DNS 查询请求服务 2.有没有更好的实现方式呢？ 配置 host 文件，\b网址映射 IP，并解析； 使用配置 dns 转发； 使用 CDN \b缓存 3.如果是自己来做，你会如何做呢？ host 配置映射 dns 配置转发 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"common/tcp.html":{"url":"common/tcp.html","title":"tcp 协议过程","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 网络层的各个环节 为什么需要 TCP 的三次握手 http1.x 为什么需要变成 http2.x 面试 TCP 协议 BBB 关键词 TCP、HTTP、HTTP2、应用层、网络、FIN、ACK ACK: 确认比特ACK，\bACK=1时，表示接收到另外一端的信息； FIN: 终止比特FIN, FIN=1时，需要释放该端的连接； What TCP 是什么，基础概念是？ 是什么 TCP 只需建立一次，支持应用层的 http1.x 和 http2.x \b多次连接； TCP 位于 传输层，是传输层其中一个协议,在应用层和网络层的中间； TCP 是 点对点 传输，广播和多播不能用于 TCP； TCP 是 双向传输 数据； TCP 传输内容 字节流 构成的； TCP 把数据变不同小块的，发放给网络层传输； 同一时间，只能发送一个请求； TCP 协议，让应用层获取完整数据的信息，可以保证数据传输的完整可靠性，同类型的 UDP 协议不能保证数据的完整性； 三次握手是什么？ 三次握手是建立通信连接 第一次：client -> server（发送给 server 信息） 第二次：server -> client（server 发送【ACK字段】给 server 确认收到） 第三次：client -> server（client 发送【\bACK字段】给 client 确认收到） 三次握手解决了什么问题? 减少 server 端资源消耗；\b正常情况，两次连接后，server 端已经保持了某个连接，但 client 的请求断开或延迟超时了，这种情况下，就可以避免资源继续等待连接的浪费； 使用三次连接，保证数据不会丢失，不会重复数据，\b保证数据的完整性； 让应用层 http 等专注于解决\b业务代码的编写； 四次握手是什么？ 四次握手是断开通信连接 第一次：client -> server (发送关闭状态给 server，client处于等待断开) 第二次：server -> client (server 发送【ACK字段】给 client 确认收到，server处于等待断开) 第三次：server -> client (server 再发数据【FIN字段】给 client，主动断开连接) 第四次：client -> server (client 确认收到，再发数据【ACK】给\bserver) 四次握手解决了什么问题? 是什么 TCP 同时断开client 和 server 的发送，因为只断开其中一端的传输，另外一端的传输还会一直继续发送 疑惑 🤔 为什么建立只要3次，断开需要4次？ 这是因为 在建立时候，只有ACK没有FIN， 在断开时候，ACK 和 FIN 是 分开为\b两次发送，【 server->client 过程 】 对于我有什么帮助？ 是什么 了解该协议，可以清楚知道怎样来提高性能,例如 keep-alive 长连接设置 了解到 为什么需要 http1.x 到 http2.x \b的底层因素 它的实现原理是什么？ 是什么 连接 ：三次握手 断开 ：四次握手 实现过程：通过相互传递 ACK=1 来确认连接\b信息，当已经双向连接来回3次确认后，才可以传输数据； How 我该如何使用它？ 如何实现？ Connection : keep-avlie 保持长连接，提高性能； 只需要建立一次 TCP 连接就能进行多次 HTTP 通信 PC端：只能在一定时间内复用连接，效果明显； 移动端：成效不大； 在通用首部字符(请求头) 设置 由于程序是在 \b应用层 实现的，所以程序员不用接触实现\b源码，或者有更改该协议的处理； 有没有更好的实现方式呢？ 如何实现？ UDP 是单向的传输，性能开销小，所以速度快； UDP 的性能比 TCP 的好，但其数据的完整性无法保证； 问题在于 TCP 的两个缺点 它的缺点是什么？ Why 为什么需要它(为什么会有该问题)？ 为什么 它建立一次 \bTCP 连接，可以让应用层的 http 进行多次通信； 它相比 UDP ，可以保证数据的完整性； 如果我不用它（http1.x）呢？ 是什么 TCP 原因，为什么不用 http1.x 慢启动（slow start） 复用重用的效率比新建的高得多； 三次握手耗时 TCP建立连接时，三次握手有1.5个RTT（round-trip time）的延迟 http1.x 性能不好 http1.x 在底层 TCP 连接的复用率低下 PC端：只能在一定时间内复用连接，效果明显； 移动端：成效不大； 该如何做？ 保持长连接 升级到 http2 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 目前最好的是 \b所有转换过程自闭 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"common/http.html":{"url":"common/http.html","title":"http 的状态 ","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 http 所有状态解释 网页请求的整个过程，包含请求行解释 http1.x 相对 tcp 的缺陷（http1.x 升级到 http2.x 非常好的解释） HTTP/1.x 的连接管理（MDN） RPC 的原理 如何理解HTTP协议的 “无连接，无状态” 特点？ socket 效率高于 http 面试 http BBB 关键词 http、RTC、TCP、cookie、session、无状态、无连接 What 它是什么，基础概念是？ 是什么 web网站的请求资源的状态和过程； 由 3个部分组成： 状态行 请求头 消息主体 特点 http1.0 每个资源都会建立一次TCP 的情况; 无连接： 请求时建连接、请求完释放连接； 解决无连接： connection:keep-alive http1.0 与 http1.1 有区别 不浪费服务端资源，只有当需要资源时，才会去建立连接请求； 无状态： 每个请求是独立的，释放后，不再保存之前的访问记录； 解决无状态：cookie 和 session 保存了访问的状态，是解决上述缺点的方式 有 2xx - 5xx 四类状态； http1.x 减少请求数，http2 无限制； 在一个web服务中，一个 \bTCP 连接同时只能接收并返回一个请求；（TCP原理） 同域名下，同时只能建立 6个 TCP 连接；（connection:keep-alive） 不同域名，可以同时发起请求 传输数据是流 http1.x 减少请求数 访问网页，有下列几个过程 DNS 查询IP 建立 TCP（三次握手） 请求报文 请求行 request line （包含请求方法、URI、HTTP版本信息） 请求头 - 首部字段 request header 请求头 - 请求内容 响应报文 响应行(状态行) （包含HTTP版本、状态码、状态码的原因短语） 响应\b头 - 首部字段 response header 响应头 - 返回内容 解析返回内容(浏览器端) 断开 TCP（四次握手） 请求头 响应头 它解决了什么问题? http1.0 无状态： 每次请求完成后，不再保存之前的请求记录； 无连接： 每次请求，都需要建立一个TCP，请求完成就会关闭TCP 连接； 缺陷：耗时 开发人员，不用关注数据的传输层、网络层和链路层； http1.1 长连接 \b 替代 短连接 connection:keep-alive 每次请求，都需要建立在 tcp 之上，如果没有就建立；有 TCP 就复用（\b保持长连接）； 域名分片 线程阻塞，同时间，同域名一般建立6个TCP连接； 一个TCP连接里的多个 http 请求是按照次序发送请求的（串形的请求） HTTP 流水线 替代 长连接（串形） \b该方式，可以同时发送多个请求，\b并同时计算返回; http2.x 并行接收请求 一个TCP，多个请求可以同时被接收并返回，不会受数量限制； 表头不重复； 头信息压缩机制 \b表头压缩； multiplexing 代替 HTTP流水线 对于我有什么帮助？ 是什么 理解网站获取资源的整个实现过程； 理解 http1.x 到 http2.x 的原因； 它的实现原理是什么？ 是什么 http 协议是建立在以 TCP 协议方式之上的流数据传输； 服务端每产生一个数据\b，就会立即变成小块的发送给前端（TCP作用） How 我该如何使用它？ 如何实现？ 客户端请求时，设置请求头 服务端返回时，设置响应头 有没有更好的实现方式呢？ 如何实现？ rpc 协议：跨域了 传输层和应用层，更适合程序之间的沟通； 让网络分布式多程序更加容易； socket 是区别于 http 协议的一种方式，应用在 服务端主动传输数据到 client 端； Why 为什么需要它(为什么会有该问题)？ 为什么 它的无状态 它的无连接 它的数据完整性； http1.x 减少的请求数 http1.x缺陷：线程阻塞，在同一时间，同一域名的请求有一定数量限制，超过限制（一般开启6个TCP请求 connection:keep-alive),每个 TCP 连接是按照次序发送请求的，超过数目的请求会被阻塞 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 RPC 协议，解决微服务后，各个应用程序之间的联通 HTTP 流水线 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"common/安全/webSafe.html":{"url":"common/安全/webSafe.html","title":"xss 和 csrf 方法?","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 (非常好的网址)csrf 真实的盗用了 gmail 的例子 各种安全机制解释 白话xss vs csrf 参考知乎 : 简洁说明 xss 和 csrf python字符转义 - 字符-十六进制 对应表 跨站攻击 BBB 关键词 XSS、CSRF、XSRF、web安全、Referer Referer:记录了该HTTP请求的来源地址 What 它是什么，基础概念是？ 前提：csrf 的执行，需要经过 xss 收集到个人信息 xss是什么 用户过分信任网站，网站执行了伪造者的请求接口，泄漏\b了用户信息； XSRF：利用 cookie 获取个人信息后，再 \b进行 csrf 的伪造操作， 攻击者盗用用户的信息，再去做坏事（仅仅是收集信息）； csrf 是什么 网站过分信任用户，攻击者伪造用户的操作提交某些请求（已经触发了某些行为）； 例如，伪装成用户，访问某些接口，提交敏感信息； 它带来了什么问题? xss 带来什么问题 用户的个人信息被盗用 csrf 带来什么问题 用户执行了被攻击者伪造的操纵； 解决了有什么好处 解决 xss 有什么好处 增强编码方式，减少用户个人信息被盗，增强安全性； 解决 csrf 有什么好处 减少用户被伪造执行操作，防止个人损失； 它的实现原理是什么？ xss 原理是什么 在可输入的地方，被攻击者输入并提交（注入）了某些 js 代码； xss 获取个人信息方式，一般是通过\b restful 得到用户 cookie； csrf 原理是什么 被埋入了\bxss 或其他的后门操作； 用户的某些操作被\b伪造而被触发； How 是如何注入到前端的 在可输入的地方输入信息（被注入的\bjs代码）并提交； xss 是如何注入攻击的 攻击者可以直接通过 URL (类似：https://xx.com/xx?default=`alert(document.cookie)`) 注入可执行的脚本代码。 \b\bcsrf 诱导用户，在当前网站，访问了其他网站的页面，导致个人信息被盗用，从而继续被伪装成用户执行了操作； xss 被注入 csrf 被注入执行某些操作 var inputA = 1 var inputB= '2&c=3' // 被注入 执行了 \bcsrf var url = `http://www.xxx.com?a=${inputA}&b=${inputB}` // post 请求... 我该如何解决它？ xss 如何解决？ 解决的原则：防止被输入 可执行的js代码 前端通过 escape 转义后， 的特殊符号<> 会被转义成字符串 前端接收：前端接收后端数据，都需要进行(escape)转义后再渲染； 前端渲染：\b前端尽量不要用 dom api操作； 后端输出：后端输出给前端，都需要先转义后再给前端 后端接收：后端接收前端数据，都需要进行转义后再处理入库； var text = escape('alert(1)'); document.body.innerHTML = text csrf 如何解决？ 解决原则： 防止用户请求时，难以被伪造； 做法：添加额外的信息，让攻击者难以伪造； 进行(escape)转义 前端接收后端数据，都需要进行(escape)转义后再渲染； 尽量使用 POST； 使用 post 请求时，执行某些交互操作时，个人信息可以被隐藏； 增加验证码 敏感接口处，添加\b交互操作，例如 验证码或者输入密码； 用户可以看到互动操作，发现不知情的操作； 增加 token 增加token认证，每个请求，攻击者无法模拟用户的请求接口； token 具有过期时间，过期时间后，伪造者使用过期 token，无法再发送请求； 检测 Referer（同源策略保护） 检测接口来源的 Referer，限制接口的网址来源；（可以被修改） 设置 Samesite=Strict\b，防止网页内的第三方域名网站获取到 该 cookieSet-Cookie: foo=1; Samesite=Strict // foo 不能被第三方域名访问 Set-Cookie: bar=2; Samesite=Lax // bar 可以 Set-Cookie: baz=3 CSRFTester 检测 csrf 漏洞的工具 有没有更好的实现方式呢？ xss如何实现？ 控制 cookie 的 httpOnly,限制被访问到 cookie； 设置 cookie 的严格模式； csrf 更好的解决方法？ 如果有点击第三方网站链接，再次提醒用户 Why 为什么需要它(为什么会有该问题)？ xss 转义（escape）解决办法的作用 escape 转义的目的：是将一些构成 HTML 标签的元素转义，比如 ，空格 等，转义成 ，  等显示转义字符。有很多开源的工具可以协助我们做 escape 转义。 列出来 字符转义对应表 字符值 URL编码值 空格 %20 \" %22 # %23 % %25 & %26 ( %28 ) %29 + %2B , %2C / %2F : %3A ; %3B %3E ? %3F @ %4o \\ %5C | %7C python 如果我不用它呢？ 为什么 必须关注 xss 和 csrf； 如果是自己来做，你会如何做呢？ 如何实现？ 如果是我来做，限制第三方网站，获取当前的 cookie； 有没有什么类似的工具或方式呢？ 为什么 CSRFTester 检测 csrf 漏洞的工具 登陆该工具，访问真实接口后，再修改调试接口，查找漏洞； 设置 Samesite=Strict\b 兼容性不够，只有 chrome 和 firefox 兼容 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:42:37 "},"performance/":{"url":"performance/","title":"性能优化","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"performance/前端性能优化/":{"url":"performance/前端性能优化/","title":"前端性能优化","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:47:23 "},"performance/algorithm/":{"url":"performance/algorithm/","title":"算法类","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:03:50 "},"js/":{"url":"js/","title":"JS","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"js/函数作用域vs块级作用域.html":{"url":"js/函数作用域vs块级作用域.html","title":"js 函数作用域(闭包) vs 块级作用域","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 JavaScript的函数作用域和块级作用域概念理解 ES6 中 let 暂时性死区详解 关键词 块级作用、块级作用域、关键词3、关键词4 暂时性死区概念： 当程序的控制流程在新的作用域（module function 或 block 作用域）进行实例化时，在此作用域中用let/const声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。 关键词2： 解释 What 🐎 它是什么，基础概念是？ 块级作用域 是什么 由 花括号 封闭作用域范围 花括号之外，会立即被销毁； 花括号之外，都不能访问到其块级变量； (let、const )变量不能被提升； 函数作用域 是什么 由 函数 封闭作用域范围; 函数之外，会立即被销毁； 函数之外，都不能访问到其函数内变量； 块作用域变量是包含在函数内的； (var) 变量会被提升 它解决了什么问题? 块级作用域\b 让 for循环之类的块级变量，作用域限制在花括号内部，花括号之外不能被访问到； (function(){ for(var i=0;i 函数作用域 函数外获取不到函数内部的变量值，封闭执行环境，防止污染外部环境； ```js (function(){ for(var i=0;i // ... 处理 } })() alert(i) // 报错 ```js var arr = []; for(var i = 0; i 根据函数的作用链，\b查找到只有一个变量i，\b打印时候，被提升覆盖过，所以打印的是2； 它的实现原理是什么？ 块级作用域 \b暂时性死区(temporal dead zone)：变量提升，但未使用，若使用，会报错； 它的缺陷是什么？ 块级作用域 外部不能获取 对于我有什么帮助？ 是什么 列出来 列出来 How 🔨 我该如何使用它？ 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"js/继承.html":{"url":"js/继承.html","title":"js 继承","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 js 多种继承 列出了不同继承的优缺点 Javascript定义类（class）的三种方法(阮一峰) js instance解释 关于 Javascript 继承的全面总结 BBB 关键词 关键词1、关键词2、关键词3、关键词4 关键词1： 解释 关键词2： 解释 What 🐎 它是什么，基础概念是？ 是什么 列出来 列出来 它解决了什么问题? 是什么 列出来 列出来 它的实现原理是什么？ 是什么 列出来 列出来 它的缺陷是什么？ 是什么 列出来 对于我有什么帮助？ 是什么 列出来 列出来 How 🔨 我该如何使用它？ 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 // 使用原型构造类 //2. 使用 Object.create 构造对象的类 var Cat = { name: \"猫\", say: function () { console.log(this.name, \":\", \"喵喵喵\") } } var newCat = Object.create(Cat) // newCat.name console.log('newCat.name: ', newCat.name); // newCat.say() console.log('newCat.say(): ', newCat.say()); //3. 实现 Object.create // !解释： // 该方式，是为了让新生成的构造函数，this 指向 obj { if (!Object.create) { Object.create = function (obj) { function F() {} F.prototype = obj return new F() } } } // 测试 实现的 Object.create function testCreate(obj) { function F() {} F.prototype = obj return new F(); } var tt = testCreate(Cat) // tt.name console.log('tt.name: ', tt.name); // tt.say() console.log('tt.say() : ', tt.say()); //4. 为 createObject 的子类添加属性 { if (!Object.create) { Object.create = function (obj) { function F() {} F.prototype = obj // !已经出错，不能扩展子级属性； F.prototype.a = '1' F.prototype.b = '2' return new F() } } } var addPropCat = Object.create(Cat) // addPropCat.name console.log('addPropCat.name: ', addPropCat.name); // addPropCat.a console.log('addPropCat.a: ', addPropCat.a); // 5. 优化 Object.create 可扩展 // 缺陷： 扩展属性，需要在子类上来扩展 console.log('------ starting: ------'); { function say() { var msg = '这是 ' + this.name + ' 输出 name 结果' // console.log(msg) return msg; } // 父亲 function Father(name) { // console.log(\"father 执行\") this.name = name || 'father' } Father.prototype.fatherStaticName = 'father1' Father.prototype.father = say // 子类 function Child(name) { // ! 1. 优点：享有父类实例属性，传入参数可影响继承父类后的结果 // todo 缺点：只有父类实例属性，没有父类原型属性 // Father.call(this) // ! 1,2,3 this.name = 'children' } // ! 6. \b优点：继承父子类原型属性 // todo 缺点：原型链被修改为 Father，没有继承关系，被复制原型链 // Child.prototype = Father.prototype // ! 2. 优点：享有子类原型属性，享有父子类实例属性 // todo 缺点： 没有父类原型属性, 实例属性被父类的实力属性覆盖 // Child.prototype = Father // ! 3. 优点：是父子类的实例，共享父子类的原型属性 // todo 缺点： 和 Father.call 一起使用，多调用一次，构造器不是子类 // Child.prototype = new Father() // ! 4. 优点：享有父类的所有实例属性 // todo 缺点： 具用所有的实例化后属性，但内存开销大； // { // const father = new Father() // for (let k in father) { // Child.prototype[k] = father[k] // } // Child.prototype.name = 'children'; // todo 该执行不影响结果，可以不要 // } // ! 5. 优点：是父子类的实例，共享父子类的原型属性 // todo 缺点： 和 Father.call 一起使用，多调用一次 // Child.prototype = new Father() // Child.prototype.construtor = Child // end Child.prototype.say = say } var child = new Child() // 1，2，3 三种方式继承，下面的输出都会不一样； // child.name console.log('child.name: ', child.name); // child.fatherStaticName console.log('child.fatherStaticName: ', child.fatherStaticName); // child.say() console.log('child.say(): ', child.say()); // child instanceof Father console.log('child instanceof Father: ', child instanceof Father); // child instanceof Child console.log('child instanceof Child: ', child instanceof Child); // child.__proto__.__proto__ == Father.prototype console.log('child.__proto__.__proto__ == Father.prototype: ', child.__proto__.__proto__ == Father.prototype); // ! 2. 输出 // child.__proto__.prototype == Father.prototype console.log('child.__proto__.prototype == Father.prototype: ', child.__proto__.prototype == Father.prototype); // ! 5. 使用 constructor // console.log('child.__proto__.construtor.name == \"Child\": ', child.__proto__.construtor.name == 'Child'); // child.__proto__ console.log('child.__proto__: ', child.__proto__); var newValue = '被 Child 修改后的name属性值' Child.prototype.fatherStaticName = newValue // Father.prototype.name console.log('修改 Child.prototype.name 属性后，Father.name: ', Father.prototype.fatherStaticName); Child.__proto__.fatherStaticName = newValue var child2 = new Child() // child2.fatherStaticName console.log('child2.fatherStaticName: ', child2.fatherStaticName); // jquery 实现的类 // es6 的 class class A { a() { console.log('1') } } class B extends A { b() { super.a() } } var bb = new B() bb.b() By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:38:33 "},"js/节流_防抖.html":{"url":"js/节流_防抖.html","title":"js 节流_防抖","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 浅谈javascript的函数节流 函数节流与函数防抖 关键词 throttle、关键词3、关键词4 throttle： 节流 What 🐎 它是什么，基础概念是？ throttle 是什么 预先设定一个执行周期，触发动作之后，才执行处理； 应用：拖拽 触发后，固定一段时候后，才执行某个函数 // 自己实现的 function throttle(fn, timeout){ let _time0 = (new Date()).getTime() return function(){ // let args = [...arguments] var args = arguments setTimeout(function(){ if( (new Date()).getTime() - _time0 >= timeout ){ fn.apply(null, args) } },timeout) } } debounce 是什么 优化: 最后一个触发时间之后多长时间才执行节流 （其实这就是防抖） 应用：输入后的keyup 、 var timeId; \bfunction throttle(fn, timeout){ clearTimeout(timeId) let _time0 = (new Date()).getTime() return function(){ // let args = [...arguments] var args = arguments timeId = setTimeout(function(){ if( (new Date()).getTime() - _time0 >= timeout ){ fn.apply(null, args) } }, timeout) } } 它解决了什么问题? throttle 是什么 解决了高频率调用函数，造成性能降低的问题 列出来 它的实现原理是什么？ xxx 是什么 列出来 列出来 它的缺陷是什么？ xxx 是什么 列出来 对于我有什么帮助？ xxx 是什么 列出来 列出来 How 🔨 我该如何使用它？ xxx 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ xxx 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"js/js模版引擎.html":{"url":"js/js模版引擎.html","title":"js模版引擎","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 AAA BBB 关键词 关键词1、关键词2、关键词3、关键词4 关键词1： 解释 关键词2： 解释 What 🐎 它是什么，基础概念是？ xxx 是什么 列出来 列出来 ` /** JS编码实现一个render方法，使得可议这样调用： const year = ‘2017’; const month = ‘09’; const day = ‘21’; const str = render(‘year−year−{month}-${day}’)({year,month,day}); console.log(str)//输出2017-09-21 --------------------- 作者：susiwen8 来源：CSDN 原文：https://blog.csdn.net/susiwen8/article/details/82701235 版权声明：本文为博主原创文章，转载请附上博文链接！ */ // //! [marker0] function render(str, obj) { str = str.replace(/ /g, ''); const reg = /(\\w|\\d|\\s|\\_)+(?=%>)/g let matchAry = str.match(reg) return matchAry.filter(d => obj.hasOwnProperty(d)).map(d => { return obj[d] }) } var data = { year: 10 } //! [marker0] // render(\"\", data) //! [marker1] console.log('render(\"\", data): ', render(\"\", data)); //! [marker1] ` 它解决了什么问题? xxx 是什么 列出来 列出来 它的实现原理是什么？ xxx 是什么 列出来 列出来 它的缺陷是什么？ xxx 是什么 列出来 对于我有什么帮助？ xxx 是什么 列出来 列出来 How 🔨 我该如何使用它？ xxx 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ xxx 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:49:25 "},"js/sizzle.html":{"url":"js/sizzle.html","title":"sizzle dom 操作的实现","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 参考文章 sizzle 选择器 jquery 源码结构 (function(window, undefined) { var jQuery = function (selector, context) { return new jQuery.fn.init(selector, context, rootjQuery); } jQuery.fn = jQuery.prototype = {...} jQuery.fn.init.prototype = jQuery.fn; // utilities method // Deferred // support // Data cache // queue // Attribute // Event // Sizzle about 2k lines // DOM // css operation // Ajax // animation // position account window.jQuery = window.$ = jQuery; }) What 它是什么，做什么的？ 复杂节点的查询器； sizzle 只搜索 $(expression); expression 是一个表达式=> ex: $('#a > .b'); 它是一个 正则表达式匹配 返回不同节点内容 chunker = /((?:\\((?:\\([^()]+\\)|[^()]+)+\\)|\\[(?:\\[[^\\[\\]]*\\]|['\"][^'\"]*['\"]|[^\\[\\]'\"]+)+\\]|\\\\.|[^ >+~,(\\[\\\\]+)+|[>+~])(\\s*,\\s*)?((?:.|\\r|\\n)*)/g How 我该如何使用它？ 掌握它的整体结构： 入口处: function(selector, context, result, seed) 查找函数：Sizzle.find； 过滤函数: Sizzle.filter 块关系处理： Sizzle.selectors.relative ==== {“+”: function() {}, “ ”:function() {}, “>”: function() {}, “~”: function() {}} DOM树 从左到右 查找，准确度高 DOM树 从右到左 查找，查找速度快(性能好) 分割解析: 解析正则表达式 有没有更好的实现方式呢？ 如何实现？ 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 Why 为什么需要它？ 它的存在是为了兼容某些浏览器不能使用 document.querySelector 查找节点； 列出来 列出来 如果我不用它呢？ 就得自己写函数来兼容查找节点，自己实现这个过滤过程； 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:41:33 "},"js/XMLHttpRequest.html":{"url":"js/XMLHttpRequest.html","title":"XMLHttpRequest","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 MDN xmlHTTPRequest 请求 BBB 关键词 xmlHTTPRequest、关键词2、关键词3、关键词4 关键词1： 解释 关键词2： 解释 What 🐎 它是什么，基础概念是？ xmlHTTPRequest 是什么 浏览器端向服务端发送请求，获取数据过程，不用刷新浏览器； 可以只更新局部的内容； 简单模拟实现 function XHR({ url, method, fn }){ // 建立 const xhr = new XMLHttpRequest() // 设置请求参数 xhr.open(method, url, true) // 设置表头 // xhr.setRequestHeader('Accept','application/json') 默认是 * /* // 设置成功回调 xhr.onreadystatechange = function(){ if( // XMLHttpRequest.DONE == 4 xhr.readyState== XMLHttpRequest.DONE && xhr.status == 200 || xhr.status == 304 ){ let resText = isJson(xhr.responseText) fn(resText) } } // 开始触发 xhr.send() } XHR({ method:'GET', url:'https://api.github.com/users/yeyuguo/repos', fn:data=>{ console.log({data}) } }) /*转json*/ function isJson(txt,types='Object'){ if(typeof txt =='string'){ try{ return isJson(JSON.parse(txt)) }catch{ return {'error:':'返回内容非 json 格式'} } } // 具体判断是数组还是对象 var reg = /[\\w* + ('Object'||'Array'||types) + \\w*]/g var type = Object.prototype.toString.call(txt) if(reg.test(type)){ return txt } } 它解决了什么问题? xxx 是什么 列出来 列出来 它的实现原理是什么？ xxx 是什么 列出来 列出来 它的缺陷是什么？ xxx 是什么 列出来 对于我有什么帮助？ xxx 是什么 列出来 列出来 How 🔨 我该如何使用它？ xxx 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ xxx 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"js/cmd_amd_es.html":{"url":"js/cmd_amd_es.html","title":"cmd_amd_es","keywords":"","body":"参考文档 AMD 定义) 为什么需要AMD js module 加载进阶 关于Function.prototype.toString的野生小技巧 使用 commonJS 实现 define 示例请看 js/cmd_amd_es/ 什么是 CMD、AMD、ES 模块加载器 CMD 环境 在 node 端使用； 为什么需要它？ 目的是把功能模块化，模块内的变量方法等都是私有的，达到解耦的目的; 特征 同步引包； 缺点： 浏览器同步加载模块会导致性能、可用性、调试和跨域访问等问题，不适用于浏览器加载机制 CJS 没有依赖引用； 不能动态加载； 多次引入，只加载一次，除第一次，都是取的缓存数据； 导出： exports默认不写： 返回{} exports.xxx = xxx module.exports默认不写： 返回{} module.exports = xxx 同时存在，module.exports 输出优先级大于 exports, 引入： 引入包，xxx 不能是变量； exports 导出时 ```js // \bxxx.js exports.xxx = 'a' // 引入文件 var cmd = require(xxx); // cmd 是一个对象， xxx 是一个key值了 cmd.xxx - module.exports 导出时 ```js // xxx.js module.exports = xxx // 引入文件 var cmd = require(xxx); // cmd 是 导出的 xxx AMD (Asynchronous Module Definition) 不是标准规范，使用需引入相应的包，如 require.js 等一些包 为什么需要它？ 解决多个 js 文件的依赖关系； 可以使用动态加载(使用变量)； 环境v 在 browser 端； 部分库支持能在 node 运行，例如 r.js (转换成 commonJS 代码为 define 代码) 特征 异步引包； 和浏览器的异步加载环境一致； 如何 Fuction.prototype.toString() 能实现 AMD 的方法？ todo 导出： define('模块名xxx',['资源a','资源b'],function(xxx,a,b){}) 可以利用简单的 cmd 实现的 define AMD； 实现的原理： 简单的使用 fn.toString() 获取函数字符内容； 使用正则表达式 /\\brequire\\([\"'](\\w+)[\"']\\)/g; 来返回 资源包的列表 ```js define(function(require){ /* 该处结果是，返回一个数组列表的依赖包 : ['资源a','资源b']/ var a = require('a'); var b = require('b'); /** * 该处返回函数，相当于 ，第一种方式的最后一个参数，是一个回调函数处理； */ return function(){ // 对 a、b 进行处理； } }) // 另外一种实现： define(function (require, exports, module) { var a = require('a'), b = require('b'); exports.action = function () {}; }); ``` 引入： 通过 require(['xxx'],function(x){}) 方式按需加载模块包； ES 环境： brower 使用； node 端使用 特征 异步引包 import() 能做按需加载等 导出： export const a = xxx export {a,b} export default a 引入： import {a} from 'xxx' import {a,b } from 'xxx' import a from 'xxx' By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:43:30 "},"js/迭代器.html":{"url":"js/迭代器.html","title":"迭代器 generater 的实现和操作","keywords":"","body":"const log = function (msg, ...rest) { const chalk = require('chalk'); let color = rest.pop() try { console.log(chalk[color](msg), ...rest) } catch (err) { color ? console.log(msg, color, ...rest) : console.log(msg, ...rest) } // console.log(chalk[color || 'white'](msg)) // if (!color) { // return msg => console.log(chalk[color][msg]) // } else { // console.log(chalk[color][msg]) // } } const fixColor = 'blue' /**迭代器的实现 */ function makeIterator(array) { if (!(array instanceof Array)) { throw '请输入迭代数据' } let i = 0; let IterRes = { next: function () { let res = { value: i By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:54:40 "},"js/promise.html":{"url":"js/promise.html","title":"promise","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 promise 原理剖析 promise micro \btask 最好的讲解，没有之一 关键词 promise、micro、关键词3、关键词4 关键词1： 解释 关键词2： 解释 What 🐎 它是什么，基础概念是？ promise 是什么 是为了解决 js 异步的回掉黑洞； var p = new Promise(function(resolve,reject){ setTimeout(function(){ resolve('resolve result!!') },1000) }) p.then(function(data){ console.log({data}) }) 实现 resolve 可以这样 { var resolve = function(value){ return function(fn){ fn(value) // 此处 fn 就是 then 的回调函数 } } let _thenFn = resolve(value) this.then = function(fn){ _thenFn(fn) } } promise 完整 \b//优化 function _Promise(fn){ var _value function resolve(value){ _value = value return function(thenFn){ return thenFn(value) } } fn(resolve) this.then = function(fnThen){ fnThen(_value) } } 它解决了什么问题? promise解决的是什么 promise 解决了回调\b地狱问题 promise 建立了 micro task 微任务，在堆列之后、页面渲染之前执行； \b可以配合 async 使用； general 实现的原理： yield 对应出栈 next() 对应入栈 它的实现原理是什么？ xxx 是什么 列出来 列出来 它的缺陷是什么？ xxx 是什么 列出来 对于我有什么帮助？ xxx 是什么 列出来 列出来 How 🔨 我该如何使用它？ xxx 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ xxx 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 14:54:49 "},"js/requestAnimationFrame.html":{"url":"js/requestAnimationFrame.html","title":"requestAnimationFrame","keywords":"","body":"参考文章： 张旭鑫 requestAnimationFrame 讲解,包括一些 css 动画函数 极限控制刷新性能 -- 非常全面的性能讲解 MDN requestAnimationFrame 解释 MDN requestIdleCallback 解释 setTimeout 引起的过度渲染解释比较好 requestAnimationFrame 是什么？ 它是在浏览器绘制下一帧画面之前，调用此方法；也就是说，浏览器的每一帧的最后结尾时，来执行这个函数； 浏览器的帧率一般说 1000ms / 60 = 16.7 ms/次，requestAnimationFrame 执行周期 就是这个值 调用一次才会执行一次，如果要形成连续的，需要写递归实现； 不在当前标签页时，不会执行，因为不会绘制画面，所以不会执行； 参数： DOMHighResTimeStamp 是传入的参数，表示 requestAnimationFrame 被触发的时间,单个帧内，通过 requestAnimationFrame 传入多个回调函数，该参数都是同一个值； 为什么要使用它？ 它可以保证每一帧都能执行一次这个函数; setTimeout 和 setInterval 只是保证进入队列的时间，但是不能保证执行是在一帧内完成; css3 的动画不能满足全部场景，使用 requestAnimationFrame 来弥补；例如 scrollTop 的平滑滚动效果； 如果不使用它，该如何保证性能和函数执行？ 使用 setTimeout 实现，间隔时间建议 16.7 ms； 使用 setTimeout 缺点，定时器定时网队列里加入执行函数，容易造成过度绘制； 如何使用 function print(){ console.log('yes') } var cancelRAF = null; function renderPer(){ (function _temp(){ print() cancelRAF = window.requestAnimationFrame(_temp) })() } // 取消 递归 // window.cancelAnimationFrame(cancelRAF) requestIdleCallback 是什么？ 它是浏览器在 空闲时，才会去执行 的函数; \b该函数的存在意义：保证浏览器的性能，函数的优先级不高； 如何使用 function print(){ console.log('yes') } var cancelRAF = null; function renderPer(){ (function _temp(){ print() cancelRAF = window.requestIdleCallback(_temp) })() } // 取消 递归 // window.cancelIdleCallback(cancelRAF) 帧是如何实现的 主线程 ： JS执行 -> 合成层 componsite 的操作； 合成线程 ： 用户交互反馈 -> 主线程操作 -> 主线程结果 -> \b\b以 commit 形式给 GPU 渲染到页面； 主线程的过程是什么样的？ JS执行 -> Style计算 -> layout布局 -> Painting 绘制 -> Composite 合成 每帧的过程 合成线程接收信息 用户的交互操作； 进入主线程 \b 进入主线程开始 JavaScript：包含与视觉变化效果相关的js操作。包括并不限于：dom更新、元素样式动态改变、jQuery的animate函数等。 Style ：样式计算。这个过程，浏览器根据css选择器计算哪些元素应该应用哪些规则，然后将样式规则落实到每个元素上去，确定* 每个元素具体的样式。 Layout ：布局。在知道对一个元素应用哪些规则之后，浏览器即可开始计算它要占据的空间大小及其在屏幕的位置。 Painting ：绘制。绘制是填充像素的过程。它涉及绘出文本、颜色、图像、边框和阴影，基本上包括元素的每个可视部分。绘制一般是在多个表面（通常称为层）上完成的。(paint和draw的区别：paint是把内容填充到页面，而draw是把页面反映到屏幕上) Composite ：合成。由于页面的各部分可能被绘制到多层，由此它们需要按正确顺序绘制到屏幕上，以便正确渲染页面。对于与另一元素重叠的元素来说，这点特别重要，因为一个错误可能使一个元素错误地出现在另一个元素的上层。 主线程返回结果，回到合成线程 commit 给 GPU: 此处的 合成线程 接收 主线程的结果， 以 commit 方式传递信息给 GPU GPU 独立计算合成层 GPU 渲染画到网页上 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:09:21 "},"css/":{"url":"css/","title":"CSS","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:26:32 "},"css/垂直居中.html":{"url":"css/垂直居中.html","title":"css 垂直水平居中的不同实现","keywords":"","body":"` 垂直居中 .common { background: #fff; } /* 使用绝对定位来垂直居中 */ .container1::before { padding-top: 100%; display: inline-block; content: ''; } .container1 { position: relative; background-color: #333; width: 300px; height: inherit; } .center1 { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); } /* 使用 table table-cell 垂直居中 */ .container2 { display: table; height: 300px; width: 300px; background-color: #333; } .center2 { display: table-cell; vertical-align: middle; background: pink; text-align: center; } /* flex 定位 */ .container3 { background: greenyellow; width: 300px; height: 300px; display: flex; /*水平居中*/ /* justify-content: center; */ /*让当前 元素水平居中*/ /*垂直居中*/ align-items: center; } .center3 { margin: 0 auto; } 使用绝对定位来垂直居中 使用 table 作为框子,孩子使用 table-cell 孩子充满整个父节点 使用 flex : align-item 垂直居中 水平居中不是 justify-content: center; 水平居中:是对当前要素使用：margin:0 auto; ` By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:37:39 "},"css/响应式的正方形.html":{"url":"css/响应式的正方形.html","title":"css 响应式的正方形","keywords":"","body":"` 响应式正方形 .authDiv { width: 200px; background: #333; } .authDiv::before { display: block; content: ''; padding-bottom: 100%; } 为什么？ padding-top 和 padding-bottom 会有如此效果？ 是因为 padding-top 和 padding-bottom 的百分比，是和父元素的宽度有关 也就是把高度设置为100%,等价于父元素的100%宽度； ` By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:38:03 "},"css/visibility和display引出repain、reflow概念.html":{"url":"css/visibility和display引出repain、reflow概念.html","title":"css visibility和display引出repain、reflow概念","keywords":"","body":"参考文章： repain 和 reflow 浏览器获取属性造成 repain 和reflow的原因 待测试该参考文章的例子 visibility 和 display 区别 cssom 和 dom 合并过程 -> render tree CSS3 动画卡顿性能优化的完美解决方案（使用 \btransform 和 margin 来位移 200px 的区别？） todo 待认真阅读 - 如何做 css 性能检查 示例请看 css/test_repain_reflow.html 关键词： bitmap (栅格|位图) 、主线程、合成线程、GPU 区别是什么？ visibility ： 隐藏后，在 html 里依然占据位置； 没有株连性：父节点 也会影响子节点的显示隐藏，子节点使用 visibility: visible 解除这种情况； display: 隐藏后，在html里不显示，并且不占渲染树的位置； 具有株连性：重绘父节点隐藏消失后，子节点也一样消失，无法显示 display为 none，对其他属性不影响，例如 height，width 等；对其操作也不会再引起回流和重绘； 为什么？ visibility:引起浏览器的 repain 重绘，但不引起 reflow 回流； display: 引起浏览器的 repain 和 reflow； 为什么会有 repain 和 reflow 的存在？ html -> dom 、css -> cssom =====> 两者结合成 render tree 渲染树； 回流是：位置、形状变化，或者是浏览器对某些属性进行访问，如 clientHeight 等属性 重绘是：css 对dom进行一些视觉样式的改变，如颜色，背景色等； 回流比重绘造成的浏览器成本高！ 为什么尽量不要用 table呢？ 浏览器是流式计算布局，一次遍历就完成渲染树的排布，但是 table 内部需要计算多次才能计算完成； 为什么访问 浏览器某些属性 会造成 repain和reflow？ 浏览器会清空队列，防止队列里的东西对获取属性造成有影响； offsetTop/Left/Width/Height scrollTop/Left/Width/Height clientTop/Left/Width/Height getComputedStyle(), or currentStyle in IE 如果我们想要在一次reflow过后就获取元素变动过后的值, 这个时候浏览器为了获取真实的值就不得不立即flush缓存的队列 有哪些解决 repain 和 reflow 的方法吗？ 尽量减少 style 行内元素操作； 使用 absolute 对复杂动画元素激活，让其脱离文档流，否则引起附近节点的 repain； js对dom操作频繁，可以使用 documentFragment 频繁操作完节点后，再添加到文档里；（可以尽量在vdom 里操作使用） 渲染树全过程 自己总结： 渲染树生成：dom + cssom = render tree 流式布局：自动排布，输出一个盒模型，获取每个元素的精准位置信息， 绘制( 栅格化 | 位图 )：转换成浏览器的相对像素； chrome解释：下面简要概述了浏览器完成的步骤： 处理 HTML 标记并构建 DOM 树。 处理 CSS 标记并构建 CSSOM 树。 将 DOM 与 CSSOM 合并成一个渲染树。 根据渲染树来布局，以计算每个节点的几何信息。 将各个节点绘制到屏幕上。 dom 图例 cssom 图例 render tree 过程图 怎么做? 使用 \btransform 和 margin 来位移 200px 的区别？ margin 每一个像素 主线程过程： 耗时 DOM CSSOM DOM + CSSOM 渲染树(render tree) + 布局(layout [reflow] ) 绘制 (repain) 到 位图 合成线程过程 部分耗时 绘制位图到 GPU 耗时 从 GPU 内存获取位图 渲染到 屏幕； transform 全部动画只计算一次 主线程 耗时 DOM CSSOM DOM + CSSOM 渲染树 + 布局(layout [reflow] ) 绘制 到 位图 耗时 \b之后，每个像素计算一次 传递动画移动信息给 合成线程 不耗时 合成线程 部分耗时 绘制位图到 GPU 耗时 \b之后，每个像素计算一次 绘制位图到屏幕 总结： 和位图有关系的，非常耗时 减少位图的信息交互，利用 GPU 存储位图信息，主线程只通知变化； 为什么要开启硬件加速： 提高位图传输时间: 主线程 和 合成线程 的中间过程 测试访问浏览器属性，导致 repain 和reflow 的测试 document.addEventListener('DOMContentLoaded', function () { var date = new Date(); for (var i = 0; i By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:59:15 "},"css/BFC概念.html":{"url":"css/BFC概念.html","title":"css 里的 BFC 概念","keywords":"","body":"学习掌握概览 等级 What Why How - [ ] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [ ] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 刘威 我想了一下我的学习过程 1.是什么 1.1解决了什么问题 1.1.1 为什么会有这个问题 1.1.2 别人是怎么解决的 1.2 对于我有什么帮助 1.2.1 使用是否方便 1.2.2 需要看源码不 我自己该怎么解决这个问题 参考文章 10 分钟理解 BFC 原理 BBB 关键词 BFC、关键词2、关键词3、关键词4 关键词1： 解释 关键词2： 解释 What 🐎 它是什么，基础概念是？ xxx 是什么 列出来 列出来 它解决了什么问题? xxx 是什么 列出来 列出来 它的实现原理是什么？ xxx 是什么 列出来 列出来 它的缺陷是什么？ xxx 是什么 列出来 对于我有什么帮助？ xxx 是什么 列出来 列出来 How 🔨 我该如何使用它？ xxx 如何实现？ 列出来 列出来 它的缺点是什么？ 有没有更好的实现方式呢？ xxx 如何实现？ 列出来 列出来 Why 🤔 为什么需要它(为什么会有该问题)？ 为什么 列出来 列出来 如果我不用它呢？ 为什么 列出来 列出来 如果是自己来做，你会如何做呢？ 如何实现？ 列出来 列出来 有没有什么类似的工具或方式呢？ 为什么 列出来 列出来 疑惑 🤔 By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:37:32 "},"html/":{"url":"html/","title":"HTML","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:52:56 "},"html/document.html":{"url":"html/document.html","title":"window 和 document 的内容","keywords":"","body":"` document对象 .body { width: 100vw; } .left { width: 30%; text-align: right; border: 1px solid #000; } .right { border: 1px dotted #000; width: 70%; text-align: left; padding: 0; } .com { float: left; /* overflow: auto; */ box-sizing: border-box; border-bottom: none; } li { height: 25px; overflow: auto; width: 100%; display: inline-block; } window 对象查看 document 对象查看 getProps(document) // getProps(window) document.getElementById('change').addEventListener('click', onChange) function onChange(e) { // alert('y') console.log(e.target) let { dataset } = e.target let types = dataset.type getProps(eval(types)) // switch (dataset.type) { // case 'window': // console.log(dataset.type) // break; // case 'document': // console.log(dataset.type) // break; // } } function getProps(obj) { document.title = `${obj.constructor.name}` var uLeft = document.createElement('ul') var uRight = document.createElement('ul') let left = document.querySelector('.left') let right = document.querySelector('.right') left.innerHTML = '' right.innerHTML = '' for (let k in obj) { let Left = document.createElement('li') let lRight = document.createElement('li') Left.innerText = `${k}` let value = obj[k] // document[k] && console.log(\"document[k][Symbol.toStringTag] == 'HTMLAllCollection': \", document[k][Symbol.toStringTag] == // 'HTMLAllCollection'); obj[k] && obj[k].__proto__.constructor.name && console.log( `${k}.__proto__.constructor.name : `, obj[k].__proto__ .constructor.name); let types = obj[k] && obj[k].constructor.name let doc = `type:` + types + \" ` By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 17:47:36 "},"html/defer-async.html":{"url":"html/defer-async.html","title":"script 加载方式  defer  async  vs 普通方式","keywords":"","body":"参考文章详解defer和async的原理及应用 描述的非常准确的文章 英文图解 defer 和 async 验证 script defer async 例子 \b 正常 alert('async') async 后 alert('defer') \bdefer 后 defer script 在 “正常“之前下载了资源，等 html 解析完后才加载的。 合集 普通加载 async defer By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 18:03:16 "},"html/shadowDOM.html":{"url":"html/shadowDOM.html","title":"shadow DOM \b概念和意义","keywords":"","body":"学习掌握概览 等级 What Why How - [x] 初级 [怎么做] - [ ] 基础概念 - [ ] 为什么需要它 - [ ] 基本使用 - [x] 中级 [为什么] - [ ] 类比概念 - [ ] 如果我不用它呢 - [ ] 有没有什么类似的工具或方式呢 - [ ] 高级 [自己的] - [ ] 自己概念 - [ ] 有没有更好的实现方式呢？ - [ ] 如果是自己来实现，你会如何做呢？ 参考文章 神秘的 shadow-dom 浅析 shadow-dom 接口使用例子 MDN-shadow-dom What 它是什么，做什么的？ 它是浏览器，为了简化和隔离 web 不同组件功能； 例如 vedio 的封装，对开发者，只有一个 src 设置，就有播放暂停等功能； vedio 可以通过 js 或者 css 设置来修改 shadow DOM 的内部属性； var shadow = document.querySelector('#hostElement').attachShadow({ mode: 'open' }); shadow.innerHTML = 'Here is some new text'; shadow.innerHTML += 'p { color: red; }'; var shadow2 = document.querySelector('#hostElement').createShadowRoot() shadow2.innerHTML = '测试是否和上一个 p 标签影响颜色'; shadow2.innerHTML += 'p { color: blue; }'; How 我该如何使用它？ 操作已有 DOM； 附加上 shadow DOM \bdomElement.attachShadow({mode:'open'}) 操作新建 dom； 通过 js 创建 DOM 节点后，然后 attachShadow 附加 shadow DOM var shadow2 = document.createElement('p'); shadow2.setAttribute('id', 'shadowRoot') // shadow dom 影子节点 ---- start --- shadow2sd = shadow2.attachShadow({ mode: 'open' }) shadow2sd.innerHTML = '测试是否和上一个 p 标签影响颜色'; shadow2sd.innerHTML += 'p { color: blue; }'; // shadow dom 影子节点 ---- end --- document.body.appendChild(shadow2) 设置 attachShadow 属性 {mode:'open'} open:这样可以从外部修改； closed: 不能被外部修改； css 伪类修改样式 例如 : vedio 的样式修改 video::-webkit-media-controls-panel{ display:flex!important; background-color: deeppink; } \b获取 shadowDOM 的根节点 dom.shadowRoot.host == dom // true 有没有更好的实现方式呢？ 如何实现？ 使用 webpack 的 css-in-js 的插件，可以实现类似这样的独立样式 如果是自己来做，你会如何做呢？ 如何实现？ 待了解！ Why 为什么需要它？ 防止在大型项目，css会有重叠影响； 同一个标签名，是独立的空间，\b\b样式不会影响； 如果我不用它呢？ 如果不用，需 写独立的 cssem 唯一名称； 如果不用，需利用 webpack 的 css-loader 方式 利用 \bkey-value : 把 css 的样式名(cssem) 存在 value 上， key 是根据 组件文件和名称组成的唯一 key； 有没有什么类似的工具或方式呢？ webpack : css-loader By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:22:32 "},"Frame/":{"url":"Frame/","title":"框架","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:27:13 "},"Frame/React/":{"url":"Frame/React/","title":"React","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:27:16 "},"functional/":{"url":"functional/","title":"函数式编程","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:30:31 "},"other/":{"url":"other/","title":"杂文","keywords":"","body":" By yeyuguo，使用知识共享 署名-相同方式共享 4.0协议发布            此页面更新于： 2019-02-22 19:28:56 "}}